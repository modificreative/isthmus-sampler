<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ISTHMUS 1</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            font-family: 'Courier New', monospace;
            color: #0f0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 10px;
            margin: 0;
        }

        .crt-container {
            width: 100%;
            max-width: 1400px;
            background: #000;
            border: 3px solid #0f0;
            box-shadow: 
                0 0 10px #0f0,
                inset 0 0 20px rgba(0, 255, 0, 0.1);
            padding: 15px;
            position: relative;
        }

        .crt-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1000;
        }

        .header {
            text-align: center;
            border-bottom: 2px solid #0f0;
            padding-bottom: 10px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #0f0;
        }

        .header h1 {
            font-size: 28px;
            letter-spacing: 4px;
        }

        .header .subtitle {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 5px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            border: 2px solid #0f0;
            padding: 15px;
            background: rgba(0, 255, 0, 0.02);
        }

        .panel-title {
            border-bottom: 1px solid #0f0;
            padding-bottom: 5px;
            margin-bottom: 15px;
            font-size: 14px;
            letter-spacing: 2px;
        }

        .pad-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .pad {
            aspect-ratio: 1;
            border: 2px solid #0f0;
            background: #000;
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            transition: all 0.1s;
        }

        .pad:hover {
            background: rgba(0, 255, 0, 0.1);
            box-shadow: 0 0 10px #0f0;
        }

        .pad.active {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 20px #0f0;
        }

        .pad.loaded {
            border-color: #0f0;
            box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.3);
        }

        .pad.looping::before {
            content: '⟳';
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 12px;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
        }

        .pad-label {
            position: absolute;
            top: 5px;
            left: 5px;
            font-size: 10px;
        }

        .waveform-display {
            width: 100%;
            height: 200px;
            border: 2px solid #0f0;
            background: #000;
            margin-bottom: 10px;
            position: relative;
        }

        #waveformCanvas {
            width: 100%;
            height: 100%;
        }

        .waveform-visualizer {
            width: 100%;
            height: 100px;
            border: 2px solid #0f0;
            background: #000;
            margin-bottom: 15px;
            position: relative;
            box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.1);
        }

        #visualizerCanvas {
            width: 100%;
            height: 100%;
        }

        .visualizer-label {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 9px;
            opacity: 0.5;
            letter-spacing: 1px;
        }

        .trim-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .trim-point {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 3px;
            cursor: ew-resize;
            pointer-events: auto;
            z-index: 10;
        }

        .in-point {
            left: 0;
            background: rgba(0, 255, 255, 0.6);
            border-left: 2px solid #0ff;
            box-shadow: 0 0 10px #0ff;
        }

        .out-point {
            right: 0;
            background: rgba(255, 255, 0, 0.6);
            border-right: 2px solid #ff0;
            box-shadow: 0 0 10px #ff0;
        }

        .trim-region {
            position: absolute;
            top: 0;
            bottom: 0;
            background: rgba(0, 255, 0, 0.1);
            border-left: 1px dotted #0f0;
            border-right: 1px dotted #0f0;
            pointer-events: none;
        }

        .trim-point::before {
            content: '';
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 40px;
            margin-left: -10px;
        }

        .in-point::after {
            content: 'IN';
            position: absolute;
            top: 5px;
            left: 5px;
            font-size: 9px;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
        }

        .out-point::after {
            content: 'OUT';
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 9px;
            color: #ff0;
            text-shadow: 0 0 5px #ff0;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .bpm-editor-controls {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #0f0;
            background: rgba(0, 255, 0, 0.02);
        }

        .small-btn {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 4px 8px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .small-btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 5px #0f0;
        }

        .small-btn:active {
            transform: scale(0.95);
        }

        .control-label {
            font-size: 11px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            background: transparent;
            height: 20px;
        }

        input[type="range"]::-webkit-slider-track {
            background: #000;
            border: 1px solid #0f0;
            height: 4px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: #0f0;
            border: 1px solid #0f0;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 5px #0f0;
        }

        input[type="range"]::-moz-range-track {
            background: #000;
            border: 1px solid #0f0;
            height: 4px;
        }

        input[type="range"]::-moz-range-thumb {
            width: 15px;
            height: 15px;
            background: #0f0;
            border: 1px solid #0f0;
            cursor: pointer;
            box-shadow: 0 0 5px #0f0;
        }

        button {
            background: #000;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 8px 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        button:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 10px #0f0;
        }

        button:active {
            transform: scale(0.95);
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .status-bar {
            border-top: 2px solid #0f0;
            padding-top: 10px;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
        }

        .status-item {
            opacity: 0.7;
        }

        .export-section {
            grid-column: 1 / -1;
        }

        .sequencer-section {
            grid-column: 1 / -1;
        }

        .sequencer-controls {
            margin-bottom: 15px;
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 20px;
            align-items: center;
        }

        .bpm-counter-display {
            background: #000;
            border: 3px solid #0f0;
            padding: 15px 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 
                inset 0 0 20px rgba(0, 255, 0, 0.2),
                0 0 10px rgba(0, 255, 0, 0.3);
            min-width: 150px;
        }

        .bpm-large {
            font-size: 48px;
            font-weight: bold;
            line-height: 1;
            text-shadow: 0 0 15px #0f0;
            letter-spacing: 2px;
            font-family: 'Courier New', monospace;
        }

        .bpm-label {
            font-size: 12px;
            letter-spacing: 3px;
            opacity: 0.7;
            margin-top: 5px;
        }

        .bpm-counter-display.beating {
            animation: bpmPulse 0.1s ease-out;
        }

        @keyframes bpmPulse {
            0% { 
                box-shadow: 
                    inset 0 0 20px rgba(0, 255, 0, 0.2),
                    0 0 10px rgba(0, 255, 0, 0.3);
            }
            50% { 
                box-shadow: 
                    inset 0 0 30px rgba(0, 255, 0, 0.4),
                    0 0 20px rgba(0, 255, 0, 0.6);
            }
            100% { 
                box-shadow: 
                    inset 0 0 20px rgba(0, 255, 0, 0.2),
                    0 0 10px rgba(0, 255, 0, 0.3);
            }
        }

        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }

            .crt-container {
                padding: 10px;
                border-width: 2px;
            }

            .header h1 {
                font-size: 18px;
                letter-spacing: 2px;
            }

            .header .subtitle {
                font-size: 9px;
            }

            .main-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .panel {
                padding: 10px;
            }

            .panel-title {
                font-size: 11px;
                letter-spacing: 1px;
            }

            .pad-grid {
                gap: 6px;
            }

            .pad {
                font-size: 14px;
            }

            .pad-label {
                font-size: 8px;
            }

            button {
                padding: 6px 10px;
                font-size: 10px;
            }

            .button-group {
                gap: 6px;
                flex-wrap: wrap;
            }

            .control-label {
                font-size: 9px;
            }

            .control-group {
                margin-bottom: 10px;
            }

            .waveform-display {
                height: 150px;
            }

            .waveform-visualizer {
                height: 80px;
            }

            .sample-info {
                font-size: 8px;
            }

            .status-bar {
                font-size: 9px;
                flex-direction: column;
                gap: 5px;
                align-items: flex-start;
            }

            .bpm-counter-display {
                padding: 10px 15px;
                min-width: 100px;
            }

            .bpm-large {
                font-size: 32px;
            }

            .bpm-label {
                font-size: 10px;
            }

            .sequencer-controls {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .sequencer-grid {
                padding: 3px;
                gap: 1px;
                overflow-x: auto;
            }

            .seq-row {
                grid-template-columns: 35px repeat(16, 1fr);
                gap: 1px;
            }

            .seq-label {
                font-size: 8px;
            }

            .seq-step {
                min-width: 20px;
            }

            .help-btn {
                width: 35px;
                height: 35px;
                font-size: 20px;
                top: 10px;
                right: 10px;
            }

            .tutorial-panel {
                max-width: 95vw;
                max-height: 85vh;
            }

            .tutorial-header {
                padding: 10px 15px;
            }

            .tutorial-title {
                font-size: 14px;
                letter-spacing: 2px;
            }

            .tutorial-content {
                padding: 20px 15px;
                font-size: 13px;
            }

            .tutorial-step h2 {
                font-size: 16px;
            }

            .tutorial-footer {
                padding: 10px 15px;
            }

            .tutorial-btn {
                padding: 6px 12px;
                font-size: 10px;
            }

            .integration-buttons {
                grid-template-columns: 1fr;
            }

            select {
                font-size: 10px;
                padding: 4px;
            }

            input[type="range"] {
                height: 18px;
            }

            .keyboard-hint {
                font-size: 7px;
            }

            .envelope-visual {
                height: 60px;
            }

            .controls-grid {
                grid-template-columns: 1fr;
            }

            .bpm-editor-controls {
                padding: 8px;
            }

            .small-btn {
                padding: 3px 6px;
                font-size: 9px;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 14px;
                letter-spacing: 1px;
            }

            .header .subtitle {
                font-size: 7px;
            }

            .crt-container {
                padding: 8px;
            }

            .panel {
                padding: 8px;
            }

            .pad-grid {
                gap: 4px;
            }

            .pad {
                font-size: 12px;
            }

            button {
                padding: 5px 8px;
                font-size: 9px;
            }

            .bpm-large {
                font-size: 24px;
            }

            .waveform-display {
                height: 120px;
            }

            .waveform-visualizer {
                height: 60px;
            }

            .seq-row {
                grid-template-columns: 30px repeat(16, 1fr);
            }

            .seq-label {
                font-size: 7px;
            }

            .seq-step {
                min-width: 18px;
            }

            .tutorial-content {
                font-size: 12px;
            }
        }

        .sequencer-right-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .sequencer-grid {
            display: grid;
            gap: 2px;
            background: #000;
            border: 2px solid #0f0;
            padding: 5px;
            overflow-x: auto;
        }

        .seq-row {
            display: grid;
            grid-template-columns: 50px repeat(16, 1fr);
            gap: 2px;
            align-items: center;
        }

        .seq-label {
            font-size: 10px;
            text-align: right;
            padding-right: 5px;
            opacity: 0.7;
        }

        .seq-step {
            aspect-ratio: 1;
            border: 1px solid #0f0;
            background: #000;
            cursor: pointer;
            position: relative;
            transition: all 0.1s;
        }

        .seq-step:hover {
            background: rgba(0, 255, 0, 0.2);
        }

        .seq-step.active {
            background: #0f0;
            box-shadow: 0 0 5px #0f0;
        }

        .seq-step.playing {
            border-color: #0ff;
            border-width: 2px;
            box-shadow: 0 0 10px #0ff;
        }

        .seq-step.beat {
            border-color: rgba(0, 255, 0, 0.5);
        }

        .seq-step.measure {
            border-color: rgba(0, 255, 0, 0.8);
            border-width: 2px;
        }

        .integration-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .sample-info {
            font-size: 10px;
            opacity: 0.6;
            margin-top: 5px;
        }

        .blink {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .tutorial-overlay.active {
            display: flex;
        }

        .tutorial-panel {
            background: #000;
            border: 3px solid #0f0;
            box-shadow: 0 0 20px #0f0;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        .tutorial-header {
            border-bottom: 2px solid #0f0;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tutorial-title {
            font-size: 18px;
            letter-spacing: 3px;
            text-shadow: 0 0 10px #0f0;
        }

        .close-tutorial {
            background: transparent;
            color: #0f0;
            border: none;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .close-tutorial:hover {
            color: #000;
            background: #0f0;
            text-shadow: none;
        }

        .tutorial-content {
            padding: 30px;
            flex: 1;
            overflow-y: auto;
            line-height: 1.6;
        }

        .tutorial-step {
            display: none;
        }

        .tutorial-step.active {
            display: block;
        }

        .tutorial-step h2 {
            font-size: 20px;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #0f0;
            letter-spacing: 2px;
        }

        .tutorial-step p {
            margin-bottom: 12px;
            opacity: 0.9;
        }

        .tutorial-step ul {
            margin: 15px 0;
            padding-left: 20px;
        }

        .tutorial-step li {
            margin-bottom: 8px;
            opacity: 0.85;
        }

        .tutorial-step .highlight {
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
        }

        .tutorial-footer {
            border-top: 2px solid #0f0;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tutorial-btn {
            background: #000;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 8px 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .tutorial-btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 10px #0f0;
        }

        .tutorial-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .tutorial-btn:disabled:hover {
            background: #000;
            color: #0f0;
            box-shadow: none;
        }

        .tutorial-progress {
            font-size: 14px;
            letter-spacing: 2px;
        }

        .help-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: #000;
            color: #0f0;
            border: 2px solid #0f0;
            border-radius: 50%;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            z-index: 9999;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Courier New', monospace;
        }

        .help-btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 15px #0f0;
            transform: scale(1.1);
        }

        input[type="file"] {
            display: none;
        }

        .file-label {
            display: inline-block;
            background: #000;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 8px 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .file-label:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 10px #0f0;
        }

        .keyboard-hint {
            font-size: 9px;
            opacity: 0.5;
            margin-top: 10px;
        }

        .envelope-visual {
            width: 100%;
            height: 80px;
            border: 1px solid #0f0;
            background: #000;
            margin-top: 10px;
            position: relative;
        }

        #envelopeCanvas {
            width: 100%;
            height: 100%;
        }

        select {
            background: #000;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 5px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="crt-container">
        <div class="header">
            <h1>▒▒▒ ISTHMUS 1 ▒▒▒</h1>
            <div class="subtitle">INTEGRATED SAMPLE PLAYBACK SYSTEM</div>
        </div>

        <!-- Tutorial Overlay -->
        <div class="tutorial-overlay" id="tutorialOverlay">
            <div class="tutorial-panel">
                <div class="tutorial-header">
                    <div class="tutorial-title">▒ ISTHMUS 1 TUTORIAL ▒</div>
                    <button id="closeTutorial" class="close-tutorial">✕</button>
                </div>
                <div class="tutorial-content" id="tutorialContent">
                    <!-- Tutorial steps will be dynamically inserted here -->
                </div>
                <div class="tutorial-footer">
                    <button id="prevStep" class="tutorial-btn">◀ PREV</button>
                    <div class="tutorial-progress">
                        <span id="currentStep">1</span> / <span id="totalSteps">6</span>
                    </div>
                    <button id="nextStep" class="tutorial-btn">NEXT ▶</button>
                </div>
            </div>
        </div>

        <!-- Help Button -->
        <button id="helpBtn" class="help-btn">?</button>

        <div class="main-grid">
            <!-- Sample Pads -->
            <div class="panel">
                <div class="panel-title">► SAMPLE PADS</div>
                <div class="pad-grid" id="padGrid"></div>
                <div class="button-group">
                    <label class="file-label">
                        LOAD SAMPLE
                        <input type="file" id="fileInput" accept="audio/*" multiple>
                    </label>
                    <button id="clearBtn">CLEAR ALL</button>
                </div>
                <div class="control-group" style="margin-top: 15px;">
                    <div class="control-label">
                        <span>PLAYBACK MODE</span>
                    </div>
                    <select id="playbackMode">
                        <option value="trigger">TRIGGER (PRESS & HOLD)</option>
                        <option value="oneshot">ONE-SHOT (FULL PLAY)</option>
                    </select>
                </div>
                <div class="keyboard-hint">KEYBOARD: Q W E R / A S D F / Z X C V / 1 2 3 4</div>
            </div>

            <!-- Waveform Display -->
            <div class="panel">
                <div class="panel-title">► WAVEFORM DISPLAY</div>
                <div class="waveform-display">
                    <canvas id="waveformCanvas"></canvas>
                    <div id="trimOverlay" class="trim-overlay" style="display: none;">
                        <div id="inPoint" class="trim-point in-point"></div>
                        <div id="outPoint" class="trim-point out-point"></div>
                        <div id="trimRegion" class="trim-region"></div>
                    </div>
                </div>
                <div class="waveform-visualizer">
                    <canvas id="visualizerCanvas"></canvas>
                    <div class="visualizer-label">LIVE OUTPUT</div>
                </div>
                <div class="button-group" style="margin-top: 10px;">
                    <button id="toggleEditorBtn">EDITOR: OFF</button>
                    <button id="toggleLoopBtn" style="display: none;">LOOP: OFF</button>
                    <button id="detectBpmBtn" style="display: none;">DETECT BPM</button>
                    <button id="resetTrimBtn" style="display: none;">RESET TRIM</button>
                    <button id="applyTrimBtn" style="display: none;">APPLY TRIM</button>
                </div>
                <div class="bpm-editor-controls" id="bpmEditorControls" style="display: none;">
                    <div class="control-group">
                        <div class="control-label">
                            <span>SAMPLE BPM</span>
                            <span id="sampleBpmValue">--</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="sampleBpm" min="60" max="200" step="0.1" value="120">
                            <button id="syncBpmToSeq" class="small-btn">SYNC→SEQ</button>
                            <button id="halveBtn" class="small-btn">÷2</button>
                            <button id="doubleBtn" class="small-btn">×2</button>
                        </div>
                    </div>
                </div>
                <div class="sample-info" id="sampleInfo">NO SAMPLE LOADED</div>
                <div class="sample-info" id="trimInfo" style="display: none;">IN: 0.000s | OUT: 0.000s | LENGTH: 0.000s</div>
                <div class="sample-info" id="bpmInfo" style="display: none;">BARS IN TRIM: -- | BEATS: --</div>
            </div>

            <!-- Synthesis Controls -->
            <div class="panel">
                <div class="panel-title">► SYNTHESIS CONTROLS</div>
                <div class="controls-grid">
                    <div class="control-group">
                        <div class="control-label">
                            <span>ATTACK</span>
                            <span id="attackValue">0.01</span>
                        </div>
                        <input type="range" id="attack" min="0.001" max="2" step="0.001" value="0.01">
                    </div>
                    <div class="control-group">
                        <div class="control-label">
                            <span>DECAY</span>
                            <span id="decayValue">0.1</span>
                        </div>
                        <input type="range" id="decay" min="0.001" max="2" step="0.001" value="0.1">
                    </div>
                    <div class="control-group">
                        <div class="control-label">
                            <span>SUSTAIN</span>
                            <span id="sustainValue">0.7</span>
                        </div>
                        <input type="range" id="sustain" min="0" max="1" step="0.01" value="0.7">
                    </div>
                    <div class="control-group">
                        <div class="control-label">
                            <span>RELEASE</span>
                            <span id="releaseValue">0.3</span>
                        </div>
                        <input type="range" id="release" min="0.001" max="3" step="0.001" value="0.3">
                    </div>
                    <div class="control-group">
                        <div class="control-label">
                            <span>PITCH</span>
                            <span id="pitchValue">0</span>
                        </div>
                        <input type="range" id="pitch" min="-12" max="12" step="1" value="0">
                    </div>
                    <div class="control-group">
                        <div class="control-label">
                            <span>FILTER FREQ</span>
                            <span id="filterValue">5000</span>
                        </div>
                        <input type="range" id="filter" min="100" max="10000" step="10" value="5000">
                    </div>
                    <div class="control-group">
                        <div class="control-label">
                            <span>RESONANCE</span>
                            <span id="resonanceValue">1</span>
                        </div>
                        <input type="range" id="resonance" min="0.1" max="20" step="0.1" value="1">
                    </div>
                    <div class="control-group">
                        <div class="control-label">
                            <span>VOLUME</span>
                            <span id="volumeValue">0.8</span>
                        </div>
                        <input type="range" id="volume" min="0" max="1" step="0.01" value="0.8">
                    </div>
                </div>
                <div class="envelope-visual">
                    <canvas id="envelopeCanvas"></canvas>
                </div>
            </div>

            <!-- Integration & Export -->
            <div class="panel export-section">
                <div class="panel-title">► INTEGRATION & EXPORT</div>
                <div class="control-group">
                    <div class="control-label">
                        <span>MIDI OUTPUT</span>
                    </div>
                    <select id="midiOutput">
                        <option>NONE</option>
                    </select>
                </div>
                <div class="integration-buttons">
                    <button id="sendToSequencer">SEND TO SEQUENCER</button>
                    <button id="sendToSynth">SEND TO SYNTH</button>
                    <button id="exportPreset">EXPORT PRESET</button>
                    <button id="importPreset">IMPORT PRESET</button>
                    <button id="recordOutput">RECORD OUTPUT</button>
                    <button id="exportSamples">EXPORT BANK</button>
                </div>
            </div>

            <!-- Sequencer -->
            <div class="panel sequencer-section">
                <div class="panel-title">► PATTERN SEQUENCER</div>
                <div class="sequencer-controls">
                    <div class="bpm-counter-display">
                        <div class="bpm-large" id="bpmLarge">120</div>
                        <div class="bpm-label">BPM</div>
                    </div>
                    <div class="sequencer-right-controls">
                        <div class="control-group">
                            <div class="control-label">
                                <span>TEMPO</span>
                            </div>
                            <div class="slider-container">
                                <input type="range" id="bpm" min="60" max="200" step="1" value="120">
                            </div>
                        </div>
                        <div class="control-group">
                            <div class="control-label">
                                <span>STEPS</span>
                            </div>
                            <select id="stepCount">
                                <option value="8">8</option>
                                <option value="16" selected>16</option>
                                <option value="32">32</option>
                            </select>
                        </div>
                    </div>
                    <div class="button-group">
                        <button id="playSeq">▶ PLAY</button>
                        <button id="stopSeq">■ STOP</button>
                        <button id="clearSeq">CLEAR</button>
                        <button id="tapTempo">TAP TEMPO</button>
                    </div>
                </div>
                <div class="sequencer-grid" id="sequencerGrid"></div>
            </div>
        </div>

        <div class="status-bar">
            <div class="status-item">AUDIO ENGINE: <span id="audioStatus">READY</span></div>
            <div class="status-item">SAMPLES LOADED: <span id="samplesLoaded">0</span>/16</div>
            <div class="status-item">SELECTED PAD: <span id="selectedPad">NONE</span></div>
            <div class="status-item blink">●</div>
        </div>
    </div>

    <script>
        // Audio Context Setup
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        // Create analyzer for visualization
        const analyzer = audioCtx.createAnalyser();
        analyzer.fftSize = 2048;
        analyzer.connect(audioCtx.destination);
        const bufferLength = analyzer.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        let visualizerAnimationId = null;

        // Sample Bank
        const sampleBank = new Array(16).fill(null);
        const sampleBuffers = new Array(16).fill(null);
        const trimPoints = new Array(16).fill(null).map(() => ({ start: 0, end: 1 }));
        const loopEnabled = new Array(16).fill(false);
        const detectedBPM = new Array(16).fill(null);
        let selectedPad = null;
        let activeSources = new Map();
        let playbackMode = 'trigger'; // 'trigger' or 'oneshot'
        let editorEnabled = false;
        let draggingPoint = null;

        // Sequencer State
        let sequencerPattern = Array(16).fill(null).map(() => Array(16).fill(false));
        let sequencerPlaying = false;
        let currentStep = 0;
        let sequencerInterval = null;
        let bpm = 120;
        let stepCount = 16;
        
        // Tap Tempo State
        let tapTimes = [];
        let tapTimeout = null;

        // ADSR Parameters
        const envelope = {
            attack: 0.01,
            decay: 0.1,
            sustain: 0.7,
            release: 0.3
        };

        // Synthesis Parameters
        const synthParams = {
            pitch: 0,
            filterFreq: 5000,
            resonance: 1,
            volume: 0.8
        };

        // Keyboard mapping
        const keyMap = {
            'q': 0, 'w': 1, 'e': 2, 'r': 3,
            'a': 4, 's': 5, 'd': 6, 'f': 7,
            'z': 8, 'x': 9, 'c': 10, 'v': 11,
            '1': 12, '2': 13, '3': 14, '4': 15
        };

        // Initialize Pad Grid
        function initPads() {
            const padGrid = document.getElementById('padGrid');
            for (let i = 0; i < 16; i++) {
                const pad = document.createElement('div');
                pad.className = 'pad';
                pad.innerHTML = `<span class="pad-label">${String.fromCharCode(65 + i)}</span>${i + 1}`;
                pad.dataset.index = i;
                pad.addEventListener('click', () => selectPad(i));
                pad.addEventListener('mousedown', () => playSample(i));
                pad.addEventListener('mouseup', () => stopSample(i));
                padGrid.appendChild(pad);
            }
        }

        // Select Pad
        function selectPad(index) {
            selectedPad = index;
            document.querySelectorAll('.pad').forEach((p, i) => {
                if (i === index) {
                    p.style.borderColor = '#0ff';
                } else {
                    p.style.borderColor = '#0f0';
                }
            });
            document.getElementById('selectedPad').textContent = String.fromCharCode(65 + index);
            
            if (sampleBuffers[index]) {
                drawWaveform(sampleBuffers[index]);
                updateSampleInfo(sampleBank[index]);
                
                if (editorEnabled) {
                    updateTrimPointPositions();
                    updateLoopButton();
                    updateBpmDisplay();
                }
            }
        }

        // Load Sample
        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            let loadIndex = selectedPad !== null ? selectedPad : 0;
            
            for (const file of files) {
                if (loadIndex >= 16) break;
                
                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                
                sampleBuffers[loadIndex] = audioBuffer;
                sampleBank[loadIndex] = {
                    name: file.name,
                    duration: audioBuffer.duration,
                    sampleRate: audioBuffer.sampleRate
                };
                
                const pad = document.querySelector(`[data-index="${loadIndex}"]`);
                pad.classList.add('loaded');
                
                loadIndex++;
            }
            
            updateSampleCount();
            if (selectedPad !== null && sampleBuffers[selectedPad]) {
                drawWaveform(sampleBuffers[selectedPad]);
                updateSampleInfo(sampleBank[selectedPad]);
            }
        });

        // Play Sample
        function playSample(index) {
            if (!sampleBuffers[index]) return;
            
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            // Stop existing source if playing
            if (activeSources.has(index)) {
                stopSample(index);
            }

            // Create nodes
            const source = audioCtx.createBufferSource();
            const gainNode = audioCtx.createGain();
            const filterNode = audioCtx.createBiquadFilter();
            
            source.buffer = sampleBuffers[index];
            source.playbackRate.value = Math.pow(2, synthParams.pitch / 12);
            
            // Enable looping if set for this pad
            source.loop = loopEnabled[index];
            
            // Configure filter
            filterNode.type = 'lowpass';
            filterNode.frequency.value = synthParams.filterFreq;
            filterNode.Q.value = synthParams.resonance;
            
            // Get trim points
            const trim = trimPoints[index];
            const duration = sampleBuffers[index].duration;
            const startTime = trim.start * duration;
            const endTime = trim.end * duration;
            const trimmedDuration = (endTime - startTime) / source.playbackRate.value;
            
            // Set loop points if looping
            if (source.loop) {
                source.loopStart = startTime;
                source.loopEnd = endTime;
            }
            
            // ADSR Envelope
            const now = audioCtx.currentTime;
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(synthParams.volume, now + envelope.attack);
            gainNode.gain.linearRampToValueAtTime(
                synthParams.volume * envelope.sustain, 
                now + envelope.attack + envelope.decay
            );
            
            // Connect nodes
            source.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(analyzer);
            
            // Start visualizer if not already running
            if (!visualizerAnimationId) {
                startVisualizer();
            }
            
            // Start with trim offset and duration (or loop indefinitely)
            if (source.loop) {
                source.start(0, startTime);
            } else {
                source.start(0, startTime, endTime - startTime);
            }
            
            // In one-shot mode (and not looping), automatically stop after sample ends
            if (playbackMode === 'oneshot' && !source.loop) {
                source.onended = () => {
                    if (activeSources.has(index)) {
                        activeSources.delete(index);
                        const pad = document.querySelector(`[data-index="${index}"]`);
                        pad.classList.remove('active');
                    }
                };
                // Schedule the release
                gainNode.gain.setValueAtTime(synthParams.volume * envelope.sustain, now + trimmedDuration);
                gainNode.gain.linearRampToValueAtTime(0, now + trimmedDuration + envelope.release);
            }
            
            activeSources.set(index, { source, gainNode });
            
            // Visual feedback
            const pad = document.querySelector(`[data-index="${index}"]`);
            pad.classList.add('active');
        }

        // Stop Sample
        function stopSample(index) {
            if (!activeSources.has(index)) return;
            
            // In one-shot mode, don't stop on release
            if (playbackMode === 'oneshot') return;
            
            const { source, gainNode } = activeSources.get(index);
            const now = audioCtx.currentTime;
            
            gainNode.gain.cancelScheduledValues(now);
            gainNode.gain.setValueAtTime(gainNode.gain.value, now);
            gainNode.gain.linearRampToValueAtTime(0, now + envelope.release);
            
            source.stop(now + envelope.release);
            activeSources.delete(index);
            
            // Visual feedback
            const pad = document.querySelector(`[data-index="${index}"]`);
            pad.classList.remove('active');
        }

        // Draw Waveform
        function drawWaveform(buffer) {
            const canvas = document.getElementById('waveformCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const data = buffer.getChannelData(0);
            const step = Math.ceil(data.length / canvas.width);
            const amp = canvas.height / 2;
            
            // Draw full waveform dimmed if editor enabled
            if (editorEnabled && selectedPad !== null) {
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
            } else {
                ctx.strokeStyle = '#0f0';
            }
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            for (let i = 0; i < canvas.width; i++) {
                const min = Math.min(...data.slice(i * step, (i + 1) * step));
                const max = Math.max(...data.slice(i * step, (i + 1) * step));
                
                ctx.moveTo(i, (1 + min) * amp);
                ctx.lineTo(i, (1 + max) * amp);
            }
            
            ctx.stroke();
            
            // Draw trimmed region highlighted
            if (editorEnabled && selectedPad !== null) {
                const trim = trimPoints[selectedPad];
                const startX = trim.start * canvas.width;
                const endX = trim.end * canvas.width;
                
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                for (let i = Math.floor(startX); i < Math.ceil(endX) && i < canvas.width; i++) {
                    const min = Math.min(...data.slice(i * step, (i + 1) * step));
                    const max = Math.max(...data.slice(i * step, (i + 1) * step));
                    
                    ctx.moveTo(i, (1 + min) * amp);
                    ctx.lineTo(i, (1 + max) * amp);
                }
                
                ctx.stroke();
            }
            
            // Center line
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.beginPath();
            ctx.moveTo(0, amp);
            ctx.lineTo(canvas.width, amp);
            ctx.stroke();
            
            // Update trim point positions
            if (editorEnabled && selectedPad !== null) {
                updateTrimPointPositions();
            }
        }

        // Draw Envelope
        function drawEnvelope() {
            const canvas = document.getElementById('envelopeCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const totalTime = envelope.attack + envelope.decay + 0.5 + envelope.release;
            const scaleX = canvas.width / totalTime;
            const scaleY = canvas.height;
            
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            // Start
            ctx.moveTo(0, scaleY);
            
            // Attack
            ctx.lineTo(envelope.attack * scaleX, 0);
            
            // Decay
            ctx.lineTo((envelope.attack + envelope.decay) * scaleX, (1 - envelope.sustain) * scaleY);
            
            // Sustain
            ctx.lineTo((envelope.attack + envelope.decay + 0.5) * scaleX, (1 - envelope.sustain) * scaleY);
            
            // Release
            ctx.lineTo((envelope.attack + envelope.decay + 0.5 + envelope.release) * scaleX, scaleY);
            
            ctx.stroke();
        }

        // Update Sample Info
        function updateSampleInfo(sample) {
            if (sample) {
                document.getElementById('sampleInfo').textContent = 
                    `${sample.name} | ${sample.duration.toFixed(2)}s | ${sample.sampleRate}Hz`;
            } else {
                document.getElementById('sampleInfo').textContent = 'NO SAMPLE LOADED';
            }
        }

        // Update Trim Point Positions
        function updateTrimPointPositions() {
            if (selectedPad === null || !sampleBuffers[selectedPad]) return;
            
            const waveform = document.querySelector('.waveform-display');
            const trim = trimPoints[selectedPad];
            const width = waveform.offsetWidth;
            
            const inPoint = document.getElementById('inPoint');
            const outPoint = document.getElementById('outPoint');
            const trimRegion = document.getElementById('trimRegion');
            
            const inPos = trim.start * width;
            const outPos = trim.end * width;
            
            inPoint.style.left = inPos + 'px';
            outPoint.style.left = outPos + 'px';
            trimRegion.style.left = inPos + 'px';
            trimRegion.style.width = (outPos - inPos) + 'px';
            
            updateTrimInfo();
        }

        // Update Trim Info Display
        function updateTrimInfo() {
            if (selectedPad === null || !sampleBuffers[selectedPad]) return;
            
            const trim = trimPoints[selectedPad];
            const duration = sampleBuffers[selectedPad].duration;
            const inTime = trim.start * duration;
            const outTime = trim.end * duration;
            const length = outTime - inTime;
            
            document.getElementById('trimInfo').textContent = 
                `IN: ${inTime.toFixed(3)}s | OUT: ${outTime.toFixed(3)}s | LENGTH: ${length.toFixed(3)}s`;
            
            // Update BPM info if BPM is set
            if (detectedBPM[selectedPad]) {
                updateBpmDisplay();
            }
        }

        // Toggle Editor
        function toggleEditor() {
            editorEnabled = !editorEnabled;
            const btn = document.getElementById('toggleEditorBtn');
            const overlay = document.getElementById('trimOverlay');
            const resetBtn = document.getElementById('resetTrimBtn');
            const applyBtn = document.getElementById('applyTrimBtn');
            const loopBtn = document.getElementById('toggleLoopBtn');
            const detectBpmBtn = document.getElementById('detectBpmBtn');
            const bpmEditorControls = document.getElementById('bpmEditorControls');
            const trimInfo = document.getElementById('trimInfo');
            const bpmInfo = document.getElementById('bpmInfo');
            
            if (editorEnabled) {
                btn.textContent = 'EDITOR: ON';
                btn.style.background = '#0f0';
                btn.style.color = '#000';
                overlay.style.display = 'block';
                resetBtn.style.display = 'inline-block';
                applyBtn.style.display = 'inline-block';
                loopBtn.style.display = 'inline-block';
                detectBpmBtn.style.display = 'inline-block';
                bpmEditorControls.style.display = 'block';
                trimInfo.style.display = 'block';
                bpmInfo.style.display = 'block';
                
                if (selectedPad !== null && sampleBuffers[selectedPad]) {
                    updateTrimPointPositions();
                    drawWaveform(sampleBuffers[selectedPad]);
                    updateLoopButton();
                    updateBpmDisplay();
                }
            } else {
                btn.textContent = 'EDITOR: OFF';
                btn.style.background = '#000';
                btn.style.color = '#0f0';
                overlay.style.display = 'none';
                resetBtn.style.display = 'none';
                applyBtn.style.display = 'none';
                loopBtn.style.display = 'none';
                detectBpmBtn.style.display = 'none';
                bpmEditorControls.style.display = 'none';
                trimInfo.style.display = 'none';
                bpmInfo.style.display = 'none';
                
                if (selectedPad !== null && sampleBuffers[selectedPad]) {
                    drawWaveform(sampleBuffers[selectedPad]);
                }
            }
        }

        // Handle Trim Point Dragging
        const inPoint = document.getElementById('inPoint');
        const outPoint = document.getElementById('outPoint');
        const waveformDisplay = document.querySelector('.waveform-display');

        inPoint.addEventListener('mousedown', (e) => {
            e.preventDefault();
            draggingPoint = 'in';
        });

        outPoint.addEventListener('mousedown', (e) => {
            e.preventDefault();
            draggingPoint = 'out';
        });

        document.addEventListener('mousemove', (e) => {
            if (!draggingPoint || selectedPad === null || !sampleBuffers[selectedPad]) return;
            
            const rect = waveformDisplay.getBoundingClientRect();
            const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
            const ratio = x / rect.width;
            
            if (draggingPoint === 'in') {
                trimPoints[selectedPad].start = Math.min(ratio, trimPoints[selectedPad].end - 0.01);
            } else if (draggingPoint === 'out') {
                trimPoints[selectedPad].end = Math.max(ratio, trimPoints[selectedPad].start + 0.01);
            }
            
            updateTrimPointPositions();
            drawWaveform(sampleBuffers[selectedPad]);
        });

        document.addEventListener('mouseup', () => {
            draggingPoint = null;
        });

        // Reset Trim
        document.getElementById('resetTrimBtn').addEventListener('click', () => {
            if (selectedPad !== null) {
                trimPoints[selectedPad] = { start: 0, end: 1 };
                updateTrimPointPositions();
                if (sampleBuffers[selectedPad]) {
                    drawWaveform(sampleBuffers[selectedPad]);
                }
            }
        });

        // Apply Trim (creates new trimmed buffer)
        document.getElementById('applyTrimBtn').addEventListener('click', async () => {
            if (selectedPad === null || !sampleBuffers[selectedPad]) return;
            
            const trim = trimPoints[selectedPad];
            const originalBuffer = sampleBuffers[selectedPad];
            const duration = originalBuffer.duration;
            const sampleRate = originalBuffer.sampleRate;
            
            const startSample = Math.floor(trim.start * duration * sampleRate);
            const endSample = Math.floor(trim.end * duration * sampleRate);
            const newLength = endSample - startSample;
            
            // Create new buffer
            const newBuffer = audioCtx.createBuffer(
                originalBuffer.numberOfChannels,
                newLength,
                sampleRate
            );
            
            // Copy trimmed audio data
            for (let channel = 0; channel < originalBuffer.numberOfChannels; channel++) {
                const originalData = originalBuffer.getChannelData(channel);
                const newData = newBuffer.getChannelData(channel);
                for (let i = 0; i < newLength; i++) {
                    newData[i] = originalData[startSample + i];
                }
            }
            
            // Replace buffer
            sampleBuffers[selectedPad] = newBuffer;
            sampleBank[selectedPad].duration = newBuffer.duration;
            
            // Reset trim points
            trimPoints[selectedPad] = { start: 0, end: 1 };
            
            // Redraw
            drawWaveform(newBuffer);
            updateSampleInfo(sampleBank[selectedPad]);
            updateTrimPointPositions();
        });

        // Editor Toggle Button
        document.getElementById('toggleEditorBtn').addEventListener('click', toggleEditor);

        // Update Loop Button Display
        function updateLoopButton() {
            if (selectedPad === null) return;
            
            const btn = document.getElementById('toggleLoopBtn');
            if (loopEnabled[selectedPad]) {
                btn.textContent = 'LOOP: ON';
                btn.style.background = '#0f0';
                btn.style.color = '#000';
            } else {
                btn.textContent = 'LOOP: OFF';
                btn.style.background = '#000';
                btn.style.color = '#0f0';
            }
        }

        // Update BPM Display
        function updateBpmDisplay() {
            if (selectedPad === null) return;
            
            const bpmInfoEl = document.getElementById('bpmInfo');
            const sampleBpmValue = document.getElementById('sampleBpmValue');
            
            if (detectedBPM[selectedPad]) {
                sampleBpmValue.textContent = detectedBPM[selectedPad].toFixed(1);
                document.getElementById('sampleBpm').value = detectedBPM[selectedPad];
                
                // Calculate bars and beats in trimmed region
                if (sampleBank[selectedPad]) {
                    const trim = trimPoints[selectedPad];
                    const trimmedLength = (trim.end - trim.start) * sampleBank[selectedPad].duration;
                    const beatsPerSecond = detectedBPM[selectedPad] / 60;
                    const totalBeats = trimmedLength * beatsPerSecond;
                    const bars = totalBeats / 4;
                    
                    bpmInfoEl.textContent = `BARS IN TRIM: ${bars.toFixed(2)} | BEATS: ${totalBeats.toFixed(1)}`;
                }
            } else {
                sampleBpmValue.textContent = '--';
                bpmInfoEl.textContent = 'BARS IN TRIM: -- | BEATS: --';
            }
        }

        // Detect BPM from audio buffer
        function detectBPM(audioBuffer, trimStart = 0, trimEnd = 1) {
            const sampleRate = audioBuffer.sampleRate;
            const channelData = audioBuffer.getChannelData(0);
            
            // Get trimmed section
            const startSample = Math.floor(trimStart * channelData.length);
            const endSample = Math.floor(trimEnd * channelData.length);
            const trimmedData = channelData.slice(startSample, endSample);
            
            // Calculate energy in windows (for onset detection)
            const windowSize = Math.floor(sampleRate * 0.01); // 10ms windows
            const hopSize = Math.floor(windowSize / 2);
            const energies = [];
            
            for (let i = 0; i < trimmedData.length - windowSize; i += hopSize) {
                let energy = 0;
                for (let j = 0; j < windowSize; j++) {
                    energy += trimmedData[i + j] * trimmedData[i + j];
                }
                energies.push(energy / windowSize);
            }
            
            // Find peaks (onsets)
            const threshold = energies.reduce((a, b) => a + b, 0) / energies.length * 1.5;
            const peaks = [];
            
            for (let i = 1; i < energies.length - 1; i++) {
                if (energies[i] > threshold && 
                    energies[i] > energies[i - 1] && 
                    energies[i] > energies[i + 1]) {
                    peaks.push(i * hopSize / sampleRate); // Time in seconds
                }
            }
            
            if (peaks.length < 2) {
                return null;
            }
            
            // Calculate intervals between peaks
            const intervals = [];
            for (let i = 1; i < peaks.length; i++) {
                intervals.push(peaks[i] - peaks[i - 1]);
            }
            
            // Find most common interval (tempo)
            // Group similar intervals (within 5%)
            const intervalGroups = [];
            
            for (const interval of intervals) {
                let foundGroup = false;
                for (const group of intervalGroups) {
                    if (Math.abs(interval - group.avg) / group.avg < 0.05) {
                        group.intervals.push(interval);
                        group.avg = group.intervals.reduce((a, b) => a + b, 0) / group.intervals.length;
                        foundGroup = true;
                        break;
                    }
                }
                if (!foundGroup) {
                    intervalGroups.push({ intervals: [interval], avg: interval });
                }
            }
            
            // Find largest group
            intervalGroups.sort((a, b) => b.intervals.length - a.intervals.length);
            const bestInterval = intervalGroups[0].avg;
            
            // Convert to BPM
            let bpm = 60 / bestInterval;
            
            // Adjust to reasonable range (60-200 BPM)
            while (bpm < 60) bpm *= 2;
            while (bpm > 200) bpm /= 2;
            
            return Math.round(bpm);
        }

        // Loop Toggle Button
        document.getElementById('toggleLoopBtn').addEventListener('click', () => {
            if (selectedPad === null) return;
            
            loopEnabled[selectedPad] = !loopEnabled[selectedPad];
            updateLoopButton();
            
            // Update pad visual indicator
            const pad = document.querySelector(`[data-index="${selectedPad}"]`);
            if (loopEnabled[selectedPad]) {
                pad.classList.add('looping');
            } else {
                pad.classList.remove('looping');
            }
        });

        // Detect BPM Button
        document.getElementById('detectBpmBtn').addEventListener('click', () => {
            if (selectedPad === null || !sampleBuffers[selectedPad]) return;
            
            const trim = trimPoints[selectedPad];
            const detectedBpm = detectBPM(sampleBuffers[selectedPad], trim.start, trim.end);
            
            if (detectedBpm) {
                detectedBPM[selectedPad] = detectedBpm;
                updateBpmDisplay();
            } else {
                alert('Could not detect BPM. Try adjusting trim points or use a sample with clearer beats.');
            }
        });

        // Sample BPM Slider
        document.getElementById('sampleBpm').addEventListener('input', (e) => {
            if (selectedPad === null) return;
            
            const newBpm = parseFloat(e.target.value);
            detectedBPM[selectedPad] = newBpm;
            updateBpmDisplay();
        });

        // Sync BPM to Sequencer
        document.getElementById('syncBpmToSeq').addEventListener('click', () => {
            if (selectedPad === null || !detectedBPM[selectedPad]) return;
            
            bpm = Math.round(detectedBPM[selectedPad]);
            document.getElementById('bpm').value = bpm;
            document.getElementById('bpmLarge').textContent = bpm;
            
            // Restart sequencer if playing
            if (sequencerPlaying) {
                stopSequencer();
                playSequencer();
            }
            
            // Visual feedback
            const counter = document.querySelector('.bpm-counter-display');
            counter.classList.add('beating');
            setTimeout(() => counter.classList.remove('beating'), 100);
        });

        // Halve BPM
        document.getElementById('halveBtn').addEventListener('click', () => {
            if (selectedPad === null || !detectedBPM[selectedPad]) return;
            
            detectedBPM[selectedPad] = Math.max(60, detectedBPM[selectedPad] / 2);
            updateBpmDisplay();
        });

        // Double BPM
        document.getElementById('doubleBtn').addEventListener('click', () => {
            if (selectedPad === null || !detectedBPM[selectedPad]) return;
            
            detectedBPM[selectedPad] = Math.min(200, detectedBPM[selectedPad] * 2);
            updateBpmDisplay();
        });

        // Update Sample Count
        function updateSampleCount() {
            const count = sampleBuffers.filter(b => b !== null).length;
            document.getElementById('samplesLoaded').textContent = count;
        }

        // Control Updates
        document.getElementById('playbackMode').addEventListener('change', (e) => {
            playbackMode = e.target.value;
        });

        document.getElementById('attack').addEventListener('input', (e) => {
            envelope.attack = parseFloat(e.target.value);
            document.getElementById('attackValue').textContent = envelope.attack.toFixed(3);
            drawEnvelope();
        });

        document.getElementById('decay').addEventListener('input', (e) => {
            envelope.decay = parseFloat(e.target.value);
            document.getElementById('decayValue').textContent = envelope.decay.toFixed(3);
            drawEnvelope();
        });

        document.getElementById('sustain').addEventListener('input', (e) => {
            envelope.sustain = parseFloat(e.target.value);
            document.getElementById('sustainValue').textContent = envelope.sustain.toFixed(2);
            drawEnvelope();
        });

        document.getElementById('release').addEventListener('input', (e) => {
            envelope.release = parseFloat(e.target.value);
            document.getElementById('releaseValue').textContent = envelope.release.toFixed(3);
            drawEnvelope();
        });

        document.getElementById('pitch').addEventListener('input', (e) => {
            synthParams.pitch = parseFloat(e.target.value);
            document.getElementById('pitchValue').textContent = synthParams.pitch;
        });

        document.getElementById('filter').addEventListener('input', (e) => {
            synthParams.filterFreq = parseFloat(e.target.value);
            document.getElementById('filterValue').textContent = synthParams.filterFreq.toFixed(0);
        });

        document.getElementById('resonance').addEventListener('input', (e) => {
            synthParams.resonance = parseFloat(e.target.value);
            document.getElementById('resonanceValue').textContent = synthParams.resonance.toFixed(1);
        });

        document.getElementById('volume').addEventListener('input', (e) => {
            synthParams.volume = parseFloat(e.target.value);
            document.getElementById('volumeValue').textContent = synthParams.volume.toFixed(2);
        });

        // Keyboard Control
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keyMap.hasOwnProperty(key) && !e.repeat) {
                playSample(keyMap[key]);
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keyMap.hasOwnProperty(key)) {
                stopSample(keyMap[key]);
            }
        });

        // Clear All
        document.getElementById('clearBtn').addEventListener('click', () => {
            sampleBuffers.fill(null);
            sampleBank.fill(null);
            loopEnabled.fill(false);
            detectedBPM.fill(null);
            trimPoints.forEach((_, i) => {
                trimPoints[i] = { start: 0, end: 1 };
            });
            document.querySelectorAll('.pad').forEach(p => {
                p.classList.remove('loaded', 'active', 'looping');
            });
            updateSampleCount();
            document.getElementById('waveformCanvas').getContext('2d').clearRect(0, 0, 
                document.getElementById('waveformCanvas').width, 
                document.getElementById('waveformCanvas').height);
            document.getElementById('sampleInfo').textContent = 'NO SAMPLE LOADED';
            if (editorEnabled) {
                updateBpmDisplay();
            }
        });

        // Export Preset
        document.getElementById('exportPreset').addEventListener('click', () => {
            const preset = {
                envelope,
                synthParams,
                sampleNames: sampleBank.map(s => s ? s.name : null),
                trimPoints,
                loopEnabled,
                detectedBPM,
                sequencerPattern,
                bpm,
                stepCount
            };
            const blob = new Blob([JSON.stringify(preset, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `isthmus1-preset-${Date.now()}.json`;
            a.click();
        });

        // Integration Functions
        document.getElementById('sendToSequencer').addEventListener('click', () => {
            const data = {
                type: 'sampler_data',
                samples: sampleBuffers.map((buffer, i) => ({
                    index: i,
                    duration: buffer ? buffer.duration : 0,
                    name: sampleBank[i] ? sampleBank[i].name : null
                })),
                params: { envelope, synthParams }
            };
            
            // Post message to parent window or use localStorage for integration
            window.postMessage({ target: 'sequencer', data }, '*');
            alert('SENT TO SEQUENCER');
        });

        document.getElementById('sendToSynth').addEventListener('click', () => {
            const data = {
                type: 'sampler_synth',
                params: synthParams,
                envelope
            };
            
            window.postMessage({ target: 'synth', data }, '*');
            alert('SENT TO SYNTH');
        });

        // ============================================
        // SEQUENCER FUNCTIONS
        // ============================================

        // Initialize Sequencer Grid
        function initSequencer() {
            const grid = document.getElementById('sequencerGrid');
            grid.innerHTML = '';
            
            for (let row = 0; row < 16; row++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'seq-row';
                
                // Pad label
                const label = document.createElement('div');
                label.className = 'seq-label';
                label.textContent = String.fromCharCode(65 + row);
                rowDiv.appendChild(label);
                
                // Steps
                for (let step = 0; step < stepCount; step++) {
                    const stepDiv = document.createElement('div');
                    stepDiv.className = 'seq-step';
                    stepDiv.dataset.row = row;
                    stepDiv.dataset.step = step;
                    
                    // Add visual markers for beats
                    if (step % 4 === 0) {
                        stepDiv.classList.add('measure');
                    } else {
                        stepDiv.classList.add('beat');
                    }
                    
                    // Toggle step on click
                    stepDiv.addEventListener('click', () => {
                        sequencerPattern[row][step] = !sequencerPattern[row][step];
                        if (sequencerPattern[row][step]) {
                            stepDiv.classList.add('active');
                        } else {
                            stepDiv.classList.remove('active');
                        }
                    });
                    
                    rowDiv.appendChild(stepDiv);
                }
                
                grid.appendChild(rowDiv);
            }
        }

        // Update Sequencer Step Count
        function updateSequencerSteps(count) {
            stepCount = count;
            sequencerPattern = sequencerPattern.map(row => {
                const newRow = Array(count).fill(false);
                for (let i = 0; i < Math.min(row.length, count); i++) {
                    newRow[i] = row[i];
                }
                return newRow;
            });
            initSequencer();
        }

        // Play Sequencer
        function playSequencer() {
            if (sequencerPlaying) return;
            
            sequencerPlaying = true;
            currentStep = 0;
            
            const stepDuration = (60 / bpm) * 1000 / 4; // 16th notes
            const beatDuration = (60 / bpm) * 1000; // Quarter notes
            
            sequencerInterval = setInterval(() => {
                // Remove previous playing indicators
                document.querySelectorAll('.seq-step.playing').forEach(el => {
                    el.classList.remove('playing');
                });
                
                // Pulse BPM counter on beat (every 4 steps)
                if (currentStep % 4 === 0) {
                    const counter = document.querySelector('.bpm-counter-display');
                    counter.classList.add('beating');
                    setTimeout(() => counter.classList.remove('beating'), 100);
                }
                
                // Trigger samples for current step
                for (let row = 0; row < 16; row++) {
                    if (sequencerPattern[row][currentStep]) {
                        playSample(row);
                    }
                }
                
                // Highlight current step
                document.querySelectorAll(`[data-step="${currentStep}"]`).forEach(el => {
                    el.classList.add('playing');
                });
                
                // Advance step
                currentStep = (currentStep + 1) % stepCount;
            }, stepDuration);
            
            document.getElementById('playSeq').style.background = '#0f0';
            document.getElementById('playSeq').style.color = '#000';
        }

        // Stop Sequencer
        function stopSequencer() {
            sequencerPlaying = false;
            
            if (sequencerInterval) {
                clearInterval(sequencerInterval);
                sequencerInterval = null;
            }
            
            currentStep = 0;
            
            // Remove playing indicators
            document.querySelectorAll('.seq-step.playing').forEach(el => {
                el.classList.remove('playing');
            });
            
            document.getElementById('playSeq').style.background = '#000';
            document.getElementById('playSeq').style.color = '#0f0';
        }

        // Clear Sequencer Pattern
        function clearSequencer() {
            sequencerPattern = Array(16).fill(null).map(() => Array(stepCount).fill(false));
            document.querySelectorAll('.seq-step.active').forEach(el => {
                el.classList.remove('active');
            });
        }

        // Sequencer Controls
        document.getElementById('bpm').addEventListener('input', (e) => {
            bpm = parseInt(e.target.value);
            document.getElementById('bpmLarge').textContent = bpm;
            
            // Restart sequencer if playing
            if (sequencerPlaying) {
                stopSequencer();
                playSequencer();
            }
        });

        document.getElementById('stepCount').addEventListener('change', (e) => {
            const newCount = parseInt(e.target.value);
            
            const wasPlaying = sequencerPlaying;
            if (wasPlaying) {
                stopSequencer();
            }
            
            updateSequencerSteps(newCount);
            
            if (wasPlaying) {
                playSequencer();
            }
        });

        document.getElementById('playSeq').addEventListener('click', playSequencer);
        document.getElementById('stopSeq').addEventListener('click', stopSequencer);
        document.getElementById('clearSeq').addEventListener('click', clearSequencer);

        // Tap Tempo
        document.getElementById('tapTempo').addEventListener('click', () => {
            const now = Date.now();
            
            // Clear old taps after 2 seconds of inactivity
            if (tapTimeout) {
                clearTimeout(tapTimeout);
            }
            
            tapTimeout = setTimeout(() => {
                tapTimes = [];
            }, 2000);
            
            tapTimes.push(now);
            
            // Keep only last 8 taps
            if (tapTimes.length > 8) {
                tapTimes.shift();
            }
            
            // Calculate BPM from intervals
            if (tapTimes.length >= 2) {
                const intervals = [];
                for (let i = 1; i < tapTimes.length; i++) {
                    intervals.push(tapTimes[i] - tapTimes[i - 1]);
                }
                
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const newBpm = Math.round(60000 / avgInterval);
                
                // Clamp to valid range
                if (newBpm >= 60 && newBpm <= 200) {
                    bpm = newBpm;
                    document.getElementById('bpm').value = bpm;
                    document.getElementById('bpmLarge').textContent = bpm;
                    
                    // Restart sequencer if playing
                    if (sequencerPlaying) {
                        stopSequencer();
                        playSequencer();
                    }
                    
                    // Visual feedback
                    const counter = document.querySelector('.bpm-counter-display');
                    counter.classList.add('beating');
                    setTimeout(() => counter.classList.remove('beating'), 100);
                }
            }
        });

        // ============================================
        // TUTORIAL SYSTEM
        // ============================================

        const tutorialSteps = [
            {
                title: "WELCOME TO ISTHMUS 1",
                content: `
                    <p>ISTHMUS 1 is a comprehensive sample-based music production system with integrated playback, editing, and sequencing capabilities.</p>
                    <p>This brief tutorial will guide you through the main features.</p>
                    <p class="highlight">Press NEXT to continue, or press ? anytime to reopen this tutorial.</p>
                `
            },
            {
                title: "SAMPLE PADS",
                content: `
                    <p>The 16-pad grid (A-P) is your primary interface for loading and triggering samples.</p>
                    <ul>
                        <li><span class="highlight">Click "LOAD SAMPLE"</span> to load audio files to pads</li>
                        <li><span class="highlight">Click pads</span> to trigger samples</li>
                        <li><span class="highlight">Keyboard shortcuts:</span> Q-W-E-R / A-S-D-F / Z-X-C-V / 1-2-3-4</li>
                        <li><span class="highlight">Select a pad</span> (cyan border) to edit it</li>
                    </ul>
                    <p><span class="highlight">PLAYBACK MODE:</span> Toggle between TRIGGER (hold to play) and ONE-SHOT (play full sample) modes.</p>
                `
            },
            {
                title: "WAVEFORM EDITOR",
                content: `
                    <p>Enable the editor to access powerful sample manipulation tools:</p>
                    <ul>
                        <li><span class="highlight">Trim Points:</span> Drag cyan (IN) and yellow (OUT) markers to isolate sections</li>
                        <li><span class="highlight">Loop:</span> Enable seamless sample looping between trim points</li>
                        <li><span class="highlight">Detect BPM:</span> Analyze sample tempo automatically</li>
                        <li><span class="highlight">BPM Adjustment:</span> Fine-tune tempo with slider or ÷2/×2 buttons</li>
                        <li><span class="highlight">Apply Trim:</span> Permanently crop sample to trimmed region</li>
                    </ul>
                    <p>The editor shows bars and beats to help you trim to exact musical lengths.</p>
                `
            },
            {
                title: "SYNTHESIS CONTROLS",
                content: `
                    <p>Shape your sound with professional synthesis parameters:</p>
                    <ul>
                        <li><span class="highlight">ADSR Envelope:</span> Control Attack, Decay, Sustain, and Release</li>
                        <li><span class="highlight">Pitch:</span> Transpose samples ±12 semitones</li>
                        <li><span class="highlight">Filter:</span> Lowpass filter with frequency and resonance controls</li>
                        <li><span class="highlight">Volume:</span> Master output level per sample</li>
                    </ul>
                    <p>The visual envelope display updates in real-time as you adjust parameters.</p>
                `
            },
            {
                title: "PATTERN SEQUENCER",
                content: `
                    <p>Create rhythmic patterns with the 16-track step sequencer:</p>
                    <ul>
                        <li><span class="highlight">Click steps</span> to activate/deactivate sample triggers</li>
                        <li><span class="highlight">BPM Counter:</span> Large display shows current tempo, pulses on beat</li>
                        <li><span class="highlight">Tap Tempo:</span> Click rhythmically to set BPM by tapping</li>
                        <li><span class="highlight">Step Count:</span> Choose 8, 16, or 32 steps per pattern</li>
                        <li><span class="highlight">Transport:</span> Play, Stop, and Clear pattern controls</li>
                    </ul>
                    <p>The sequencer respects all sample settings (trim, loop, ADSR, pitch, filter).</p>
                `
            },
            {
                title: "WORKFLOW & INTEGRATION",
                content: `
                    <p>Typical workflow for ISTHMUS 1:</p>
                    <ol style="padding-left: 20px;">
                        <li>Load samples to pads (drums, loops, one-shots)</li>
                        <li>Use waveform editor to trim and detect BPM</li>
                        <li>Enable loop for sustained pads or melodic samples</li>
                        <li>Sync sample BPM to sequencer tempo</li>
                        <li>Program patterns in the sequencer</li>
                        <li>Adjust synthesis parameters to taste</li>
                        <li>Export presets to save your work</li>
                    </ol>
                    <p class="highlight">Press the ? button anytime to reopen this tutorial. Have fun creating!</p>
                `
            }
        ];

        let currentTutorialStep = 0;

        function renderTutorialStep(stepIndex) {
            const content = document.getElementById('tutorialContent');
            content.innerHTML = '';
            
            tutorialSteps.forEach((step, index) => {
                const stepDiv = document.createElement('div');
                stepDiv.className = 'tutorial-step' + (index === stepIndex ? ' active' : '');
                stepDiv.innerHTML = `<h2>${step.title}</h2>${step.content}`;
                content.appendChild(stepDiv);
            });
            
            document.getElementById('currentStep').textContent = stepIndex + 1;
            document.getElementById('totalSteps').textContent = tutorialSteps.length;
            document.getElementById('prevStep').disabled = stepIndex === 0;
            document.getElementById('nextStep').disabled = stepIndex === tutorialSteps.length - 1;
        }

        function showTutorial() {
            document.getElementById('tutorialOverlay').classList.add('active');
            renderTutorialStep(currentTutorialStep);
        }

        function hideTutorial() {
            document.getElementById('tutorialOverlay').classList.remove('active');
        }

        // Tutorial Controls
        document.getElementById('helpBtn').addEventListener('click', () => {
            currentTutorialStep = 0;
            showTutorial();
        });

        document.getElementById('closeTutorial').addEventListener('click', hideTutorial);

        document.getElementById('nextStep').addEventListener('click', () => {
            if (currentTutorialStep < tutorialSteps.length - 1) {
                currentTutorialStep++;
                renderTutorialStep(currentTutorialStep);
            }
        });

        document.getElementById('prevStep').addEventListener('click', () => {
            if (currentTutorialStep > 0) {
                currentTutorialStep--;
                renderTutorialStep(currentTutorialStep);
            }
        });

        // Close tutorial with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.getElementById('tutorialOverlay').classList.contains('active')) {
                hideTutorial();
            }
        });

        // Show tutorial on first load
        if (!localStorage.getItem('isthmus1_tutorial_seen')) {
            setTimeout(() => {
                showTutorial();
                localStorage.setItem('isthmus1_tutorial_seen', 'true');
            }, 500);
        }

        // ============================================
        // LIVE WAVEFORM VISUALIZER
        // ============================================

        function startVisualizer() {
            const canvas = document.getElementById('visualizerCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            function draw() {
                visualizerAnimationId = requestAnimationFrame(draw);
                
                analyzer.getByteTimeDomainData(dataArray);
                
                // Clear with slight fade effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw waveform
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#0f0';
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#0f0';
                
                ctx.beginPath();
                
                const sliceWidth = canvas.width / bufferLength;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = (v * canvas.height) / 2;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.stroke();
                
                // Draw center line
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
                ctx.shadowBlur = 0;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.stroke();
                
                // Check if audio is playing
                let hasActivity = false;
                for (let i = 0; i < bufferLength; i++) {
                    if (Math.abs(dataArray[i] - 128) > 2) {
                        hasActivity = true;
                        break;
                    }
                }
                
                // Stop visualizer if no activity for a while
                if (!hasActivity && activeSources.size === 0) {
                    setTimeout(() => {
                        if (activeSources.size === 0) {
                            stopVisualizer();
                        }
                    }, 1000);
                }
            }
            
            draw();
        }

        function stopVisualizer() {
            if (visualizerAnimationId) {
                cancelAnimationFrame(visualizerAnimationId);
                visualizerAnimationId = null;
                
                // Clear canvas
                const canvas = document.getElementById('visualizerCanvas');
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw center line
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.stroke();
            }
        }

        // Initialize visualizer canvas on load
        window.addEventListener('load', () => {
            const canvas = document.getElementById('visualizerCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Draw initial center line
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
        });

        // Redraw visualizer on window resize
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('visualizerCanvas');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        });

        // Initialize
        initPads();
        initSequencer();
        drawEnvelope();
        document.getElementById('audioStatus').textContent = 'READY';
    </script>
</body>
</html>
